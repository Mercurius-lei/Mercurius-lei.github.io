{"posts":[{"title":"算法基础","text":"","link":"/2023/09/25/algorithm_base/"},{"title":"Elasticsearch","text":"","link":"/2023/09/25/database_%20elasticsearch/"},{"title":"Sql优化","text":"","link":"/2023/09/25/database_%20optimize/"},{"title":"MySQL","text":"","link":"/2023/09/25/database_mysql/"},{"title":"常用设计模式","text":"","link":"/2023/09/25/design_pattern/"},{"title":"分布式事务","text":"","link":"/2023/09/25/distributed_%20transaction/"},{"title":"分布式基础知识点","text":"","link":"/2023/09/25/distributed_base/"},{"title":"分布式锁","text":"","link":"/2023/09/25/distributed_clock/"},{"title":"分布式配置中心","text":"","link":"/2023/09/25/distributed_config/"},{"title":"分布式ID","text":"","link":"/2023/09/25/distributed_id/"},{"title":"消息队列","text":"","link":"/2023/09/25/distributed_message_queue/"},{"title":"Redis","text":"","link":"/2023/09/25/distributed_redis/"},{"title":"Zookeeper","text":"","link":"/2023/09/25/distributed_zookeeper/"},{"title":"Java并发","text":"","link":"/2023/09/25/java_%20concurrent/"},{"title":"Gradle","text":"","link":"/2023/09/25/java_%20gradle/"},{"title":"Java IO","text":"","link":"/2023/09/25/java_%20io/"},{"title":"JVM","text":"","link":"/2023/09/25/java_%20jvm/"},{"title":"Java版本新特性","text":"","link":"/2023/09/25/java_%20new_feature/"},{"title":"Java基础知识点","text":"","link":"/2023/09/25/java_base/"},{"title":"Maven","text":"","link":"/2023/09/25/java_maven/"},{"title":"Mybatis","text":"","link":"/2023/09/25/java_mybatis/"},{"title":"Spring &amp; SpringBoot","text":"","link":"/2023/09/25/java_springboot/"},{"title":"Java线程池","text":"线程池、连接池 1 线程池1.1 线程池介绍顾名思义，线程池就是管理一系列线程的资源池，其提供了一种限制和管理线程资源的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。 这里借用《Java 并发编程的艺术》书中的部分内容来总结一下使用线程池的好处： 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。 1.2 Java Executor框架Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。 this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。可参考：https://zhuanlan.zhihu.com/p/477481115 Executor 框架结构主要由三大部分组成： **任务(Runnable /Callable)**：执行任务需要实现的 Runnable 接口 或 Callable接口。 任务的执行(Executor) 异步计算的结果(Future) 1.3 ThreadPoolExecutor 主要参数 corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。 maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 ThreadPoolExecutor其他常见参数 : keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁。 unit : keepAliveTime 参数的时间单位。 threadFactory :executor 创建新线程的时候会用到。 handler :饱和策略。 1.4 饱和策略如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略: **ThreadPoolExecutor.AbortPolicy**：抛出 RejectedExecutionException来拒绝新任务的处理。 **ThreadPoolExecutor.CallerRunsPolicy**：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。 **ThreadPoolExecutor.DiscardPolicy**：不处理新任务，直接丢弃掉。 **ThreadPoolExecutor.DiscardOldestPolicy**：此策略将丢弃最早的未处理的任务请求。 1.5 线程池创建方式（1）通过ThreadPoolExecutor构造函数来创建（推荐） （2）通过 Executor 框架的工具类 Executors 来创建。 我们可以创建多种类型的 ThreadPoolExecutor： **FixedThreadPool**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。 SingleThreadExecutor： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。 CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。 **ScheduledThreadPool**：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。 注：《阿里巴巴 Java 开发手册》强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险（Executors创建的线程池，队列长度为Interger.MAX_VALUE，可能堆积大量的请求，导致 OOM）。 1.6 阻塞队列不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。 容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）：FixedThreadPool 和 SingleThreadExector 。由于队列永远不会被放满，因此FixedThreadPool最多只能创建核心线程数的线程。 SynchronousQueue（同步队列）：CachedThreadPool 。SynchronousQueue 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，CachedThreadPool 的最大线程数是 Integer.MAX_VALUE ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。 DelayedWorkQueue（延迟阻塞队列）：ScheduledThreadPool 和 SingleThreadScheduledExecutor 。DelayedWorkQueue 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。DelayedWorkQueue 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 Integer.MAX_VALUE，所以最多只能创建核心线程数的线程。 1.7 Runnable vs CallableRunnable自 Java 1.0 以来一直存在，但Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。**Runnable 接口**不会返回结果或抛出检查异常，但是 Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。 1.8 execute() vs submit() execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否； submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法的话，如果在 timeout 时间内任务还没有执行完，就会抛出 java.util.concurrent.TimeoutException。 1.9 shutdown()VSshutdownNow() shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。 shutdownNow（） :关闭线程池，线程池的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。 1.10 isTerminated() VS isShutdown() isShutDown 当调用 shutdown() 方法后返回为 true。 isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true 1.11 线程池和 ThreadLocal线程池和 ThreadLocal共用，可能会导致线程从ThreadLocal获取到的是旧值/脏数据。这是因为线程池会复用线程对象，与线程对象绑定的类的静态属性 ThreadLocal 变量也会被重用，这就导致一个线程可能获取到其他线程的ThreadLocal 值。 可考虑使用TransmittableThreadLocal， 项目地址：https://github.com/alibaba/transmittable-thread-local 。 2 连接池参考文档（1）https://javaguide.cn/java/concurrent/java-thread-pool-summary.html","link":"/2023/09/25/java_threadpool/"},{"title":"Docker","text":"","link":"/2023/09/25/k8s_docker/"},{"title":"k8s监控","text":"","link":"/2023/09/25/k8s_monitor/"},{"title":"网络基础知识点","text":"","link":"/2023/09/25/network_base/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"todo","slug":"todo","link":"/tags/todo/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"消息队列","slug":"消息队列","link":"/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"缓存","slug":"缓存","link":"/tags/%E7%BC%93%E5%AD%98/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"k8s","slug":"k8s","link":"/tags/k8s/"},{"name":"监控","slug":"监控","link":"/tags/%E7%9B%91%E6%8E%A7/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"分布式","slug":"分布式","link":"/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"k8s","slug":"k8s","link":"/categories/k8s/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"}],"pages":[{"title":"About me","text":"一枚小码农","link":"/about/index.html"}]}